import networkx as nx
import community as community_louvain
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from termcolor import colored, cprint
from typing import NamedTuple
from dataclasses import dataclass, fields
from collections import Counter

# Installing infomap using the default g++14 compiler on my system, the script excited with c++ error.
# So I had to manually force the usage of g++12 for installation with the command below.
# CC=/usr/bin/gcc-12 CXX=/usr/bin/g++-12 pip install infomap --no-cache-dir --force-reinstall
from infomap import Infomap
import tqdm

class GraphWithData(NamedTuple):
    graph: nx.DiGraph
    infomap: dict[str, int]
    louvain: dict[str, int]

@dataclass()
class Graphs():
    """ 
    A data class that contains all the graphs and data generated by the generate_graphs() method

    ...

    Attributes
    ----------
    full : nx.DiGraph
        Nodes are subreddits, links are directed and represent hyperlinks. The weight represents the number of hyperlinks
        from one subreddit to another
    positive : nx.DiGraph
        Nodes are subreddits, links are directed and represent hyperlinks. The weight represents the number of positive
        minus the number of negative hyperlinks from one subreddit to another. We do not add links with weight < 1
    negative : nx.DiGraph
        Nodes are subreddits, links are directed and represent hyperlinks. The weight represents the number of negative
        minus the number of positive hyperlinks from one subreddit to another. We do not add links with weight < 1
    """
    full: nx.DiGraph
    positive: nx.DiGraph
    negative: nx.DiGraph

    infomap_full: dict[str, int]
    infomap_pos: dict[str, int]
    infomap_neg: dict[str, int]
    louvain_full: dict[str, int]
    louvain_pos: dict[str, int]
    louvain_neg: dict[str, int]

    def __iter__(self):
        yield self.full
        yield self.positive
        yield self.negative

    def withNames(self):
        return [(self.full, "G_full"), (self.positive, "G_positive"), (self.negative, "G_negative")]
    
    def withData(self):
        return [
            GraphWithData(self.full, self.infomap_full, self.louvain_full),
            GraphWithData(self.positive, self.infomap_pos, self.louvain_pos),
            GraphWithData(self.negative, self.infomap_neg, self.louvain_neg)
            ]
    
    @classmethod
    def fromGraphWithData(cls, data: list[GraphWithData]):
        if len(data) != 3:
            raise ValueError("List must be of length 3")
        return cls(data[0].graph, data[1].graph, data[2].graph, data[0].infomap, data[1].infomap, data[2].infomap, data[0].louvain, data[1].louvain, data[2].louvain)
    
    def exportAsGexf(self):
        for G, name in self.withNames():
            nx.write_gexf(G, f"{name}.gexf")
    
    def apply(self, func):
        result = []
        for G in self:
            result.append(func(G))
        return result

def print_connected(G: nx.DiGraph) -> float:
    comps = sorted(nx.connected_components(G.to_undirected(as_view=True)), key=len, reverse=True)
    #c = Counter(map(len, comps))
    # for k, v in sorted(Counter(map(len, comps)).items(), key=lambda item: item[1]):
    #     print(f"")
        
    print(f"{len(comps[0])} out of {len(G)} nodes({(len(comps[0]) / len(G))*100:2f}%) are part of the main subgraph.") 


def infomap_community_detection(G: nx.DiGraph) -> dict:

    # Necessary mappings as addlink expects integer ids
    node_to_id = {node: i for i, node in enumerate(G.nodes())}
    id_to_node = {i: node for node, i in node_to_id.items()}

    im = Infomap(directed=True)
    for u, v, data in G.edges(data = True):
        im.addLink(node_to_id[u], node_to_id[v], data["weight"])
    im.run()

    # Get communities
    res = {}
    for node in im.tree:
        if node.is_leaf:
            if id_to_node[node.node_id] in res:
                cprint(f"Node {id_to_node[node.node_id]} who was attributed to community {res[id_to_node[node.node_id]]} is now attributed to community {node.module_id}.", "red")
            res[id_to_node[node.node_id]] = node.module_id
    return res

def extract_main_components(gs: Graphs) -> Graphs:
    graphs: list[GraphWithData] = []
    for G, infomap, louvain in gs.withData():

        # Find largest connected component
        main_nodes = max(nx.connected_components(G.to_undirected(as_view=True)), key=len)

        # Create a new graph with only those nodes
        G_main = G.subgraph(main_nodes).copy()

        # Filter infomap grouping
        infomap_main = {}
        for subreddit, group in infomap.items():
            if subreddit in main_nodes:
                infomap_main[subreddit] = group

        # Filter louvain 
        louvain_main = {}
        for subreddit, group in louvain.items():
            if subreddit in main_nodes:
                louvain_main[subreddit] = group

        graphs.append(GraphWithData(G_main, infomap_main, louvain_main))
    
    return Graphs.fromGraphWithData(graphs)


def generate_graphs(df: pd.DataFrame) -> Graphs:
    cprint("Generate the graphs", color="green")
    gs = Graphs(nx.DiGraph(), nx.DiGraph(), nx.DiGraph(), {},{},{},{},{},{})

    # Add the links
    agg = df.groupby(["SOURCE_SUBREDDIT", "TARGET_SUBREDDIT"])["LINK_SENTIMENT"].agg(["sum", "count"]).reset_index()
    agg["inverted_sum"] = -agg["sum"]
    for _, row in agg.iterrows():
        gs.full.add_edge(
            row["SOURCE_SUBREDDIT"],
            row["TARGET_SUBREDDIT"],
            weight=row["count"]
        )
        if row["inverted_sum"] > 0:
            gs.negative.add_edge(
                row["SOURCE_SUBREDDIT"],
                row["TARGET_SUBREDDIT"],
                weight=row["inverted_sum"]
            )
        if row["sum"] > 0:
            gs.positive.add_edge(
                row["SOURCE_SUBREDDIT"],
                row["TARGET_SUBREDDIT"],
                weight=row["sum"]
            )

    # Run the infomap community detection algorithms
    # as louvain algorithm does not work on directed graphs.
    cprint("Run infomap on the graphs", color="green")
    gs.infomap_full = infomap_community_detection(gs.full)
    gs.infomap_pos = infomap_community_detection(gs.positive)
    gs.infomap_neg = infomap_community_detection(gs.negative)
    cprint("Run louvain on the graphs", color="green")
    gs.louvain_full = community_louvain.best_partition(gs.full.to_undirected())
    gs.louvain_pos = community_louvain.best_partition(gs.positive.to_undirected())
    gs.louvain_neg = community_louvain.best_partition(gs.negative.to_undirected())
    for G in tqdm.tqdm(gs):
        nx.set_node_attributes(G, gs.infomap_full, "infomap_full")
        nx.set_node_attributes(G, gs.infomap_pos, "infomap_positive")
        nx.set_node_attributes(G, gs.infomap_neg, "infomap_negative")
        nx.set_node_attributes(G, gs.louvain_full, "louvain_full")
        nx.set_node_attributes(G, gs.louvain_pos, "louvain_positive")
        nx.set_node_attributes(G, gs.louvain_neg, "louvain_negative")

    # Add an the attributes to the nodes
    cprint("Add the attributes to the graphs", color="green")
    agg = df.groupby(["SOURCE_SUBREDDIT"])["LINK_SENTIMENT"].agg(["sum", "count"]).reset_index()
    for _, row in agg.iterrows():
        for G in gs:
            subreddit = row["SOURCE_SUBREDDIT"]
            if subreddit not in G:
                G.add_node(subreddit)
            G.nodes[subreddit]["num_posts"] = row["count"]
            G.nodes[subreddit]["positivity"] = row["sum"]

    cprint("Export the graphs", color="green")
    for G, name in gs.withNames():
        print(f"{name}: nb nodes: {G.number_of_nodes()}")
        print(f"{name}: nb edges: {G.number_of_edges()}")

    return gs